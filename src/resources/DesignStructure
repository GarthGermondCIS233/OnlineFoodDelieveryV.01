# Online Food Delivery System Design Documentation

## Class Structure and Relationships

The system is designed with clear separation of concerns and follows object-oriented principles:

### Core Classes
1. **Customer**: Manages customer information and order placement
2. **Driver**: Handles delivery operations, location tracking, and rating management
3. **Order**: Processes order details and status tracking
4. **MenuItem**: Base class for food items with size and customization options
5. **OrderTracker**: Manages order status updates and notifications

## OOP Principles Implementation

### 1. Encapsulation

The codebase demonstrates strong encapsulation through:

Example from MenuItem class:
```java
public abstract class MenuItem {
    private Long id;
    private String name;
    private String description;
    private double price;
    private String category;
    private int preparationTime;
    private boolean available;

    // Controlled access through Optional
    public Optional<String> getDescription() {
        return Optional.ofNullable(description);
    }
}
```

### 2. Abstraction

The system uses both interfaces and abstract classes:

1. **Interfaces**:
- `OrderObserver`: Defines notification behavior
- `OrderSubject`: Defines subject behavior for observer pattern
- `DriverMatchingStrategy`: Abstracts driver matching logic

2. **Abstract Classes**:
- `MenuItem`: Base class for all menu items with common properties

### 3. Inheritance

The system uses inheritance through the MenuItem hierarchy, managed by MenuItemFactory:

```java
public MenuItem createMenuItem(String type, String name, String description, double basePrice) {
    return switch (type.toLowerCase()) {
        case "hamburger" -> new Hamburger(nextId++, name, description, basePrice);
        case "drink" -> new Drink(nextId++, name, description, basePrice, Size.MEDIUM);
        case "fries" -> new Fries(nextId++, name, description, basePrice, Size.MEDIUM);
        default -> throw new IllegalArgumentException("Unknown menu item type: " + type);
    };
}
```

### 4. Polymorphism

Demonstrated through:

1. **Interface Implementation**:
```java
public class CustomerNotifier implements OrderObserver {
    private final NotificationService notificationService;

    @Override
    public void update(Order order) {
        notificationService.sendOrderStatusUpdateToCustomer(order, order.getStatus());
    }
}
```

2. **Method Overriding**: Different implementations for different menu items and strategies

## Design Patterns

### 1. Builder Pattern

Used for complex order construction with validation:

```java
public class OrderBuilder {
    private Long customerId;
    private List<MenuItem> items = new ArrayList<>();
    private Location deliveryLocation;
    private String customerEmail;

    public OrderBuilder withValidatedCustomerId(Long customerId) {
        if (customerId == null || customerId <= 0) {
            throw new IllegalArgumentException("Invalid customer ID");
        }
        this.customerId = customerId;
        return this;
    }

    // Additional builder methods...

    public Order build() {
        validateOrderRequirements();
        return new Order(customerId, items, deliveryLocation, customerEmail);
    }
}
```

### 2. Observer Pattern

Implemented for order tracking and notifications:

```java
public class OrderTrackingService implements OrderSubject {
    private List<OrderObserver> observers = new ArrayList<>();

    @Override
    public void attach(OrderObserver observer) {
        observers.add(observer);
    }

    @Override
    public void notifyObservers(Order order) {
        for (OrderObserver observer : observers) {
            observer.update(order);
        }
    }
}
```

### 3. Factory Pattern

Used for creating menu items with consistent ID generation:

```java
public class MenuItemFactory {
    private static long nextId = 1;

    public MenuItem createMenuItem(String type, String name, String description, double basePrice) {
        return switch (type.toLowerCase()) {
            case "hamburger" -> new Hamburger(nextId++, name, description, basePrice);
            case "drink" -> new Drink(nextId++, name, description, basePrice, Size.MEDIUM);
            case "fries" -> new Fries(nextId++, name, description, basePrice, Size.MEDIUM);
            default -> throw new IllegalArgumentException("Unknown menu item type: " + type);
        };
    }
}
```

### 4. Strategy Pattern

Used for flexible driver matching algorithms:

```java
public interface DriverMatchingStrategy {
    Optional<Driver> findBestMatch(Order order, List<Driver> availableDrivers);
}

// Implementation in ProximityBasedMatchingStrategy
public Optional<Driver> findBestMatch(Order order, List<Driver> availableDrivers) {
    // Implementation specific to proximity-based matching
}
```

The system demonstrates modern Java practices through:
- Use of Optional for null safety
- Strong validation in builders
- Immutable objects where appropriate
- Thread-safe collections (ConcurrentHashMap)
- Clear separation of concerns

## Class Diagram
```mermaid 
classDiagram
    %% Menu Package
    class MenuItem {
        <<abstract>>
        private Long id
        private String name
        private String description
        private double price
        private String category
        private int preparationTime
        private boolean available
        public calculateTotal()
        public updatePrice(double)
        public isAvailable()
        public getDetails()
    }
    
    class Hamburger {
        private double basePrice
        public calculateTotal()
    }
    
    class Drink {
        private Size size
        public calculateTotal()
    }
    
    class Size {
        <<enumeration>>
        SMALL
        MEDIUM
        LARGE
        private double priceMultiplier
    }

    %% Order Package
    class Order {
        private Long orderId
        private Long customerId
        private Long driverId
        private List~MenuItem~ items
        private OrderStatus status
        private double totalAmount
        private LocalDateTime orderTime
        private Payment payment
        private Location deliveryLocation
        public calculateTotal()
        public updateStatus()
    }

    class OrderStatus {
        <<enumeration>>
        PLACED
        ACCEPTED
        IN_DELIVERY
        DELIVERED
    }

    %% Observer Package
    class OrderSubject {
        <<interface>>
        public attach(OrderObserver)
        public detach(OrderObserver)
        public notifyObservers(Order)
    }

    class OrderObserver {
        <<interface>>
        public update(Order)
    }

    class OrderTrackingService {
        private List~OrderObserver~ observers
        public attach(OrderObserver)
        public detach(OrderObserver)
        public notifyObservers(Order)
    }

    class CustomerNotifier {
        private NotificationService notificationService
        public update(Order)
    }

    %% User Package
    class Customer {
        private Long id
        private String name
        private String address
        private String phone
        private String email
        private List~Order~ orderHistory
        public placeOrder(List~MenuItem~)
        public rateDriver(Driver, int, String)
    }

    class Driver {
        private Long id
        private String name
        private String vehicle
        private String licenseNumber
        private Location currentLocation
        private RatingsHandler ratings
        private Order currentOrder
        private boolean isAvailable
        public acceptOrder(Order)
        public completeDelivery(Order)
    }

    %% Factory Package
    class MenuItemFactory {
        private static long nextId
        public createMenuItem(String, String, String, double)
        public createCustomMenuItem(String, String, String, double, Size)
    }

    %% Main Package
    class DeliverySystem {
        private OrderQueue orderQueue
        private Map~Long, Driver~ availableDrivers
        private Map~Long, Driver~ busyDrivers
        private OrderTracker orderTracker
        private DriverMatchingStrategy driverMatcher
        private NotificationService notificationService
        public DeliverySystem(DriverMatchingStrategy, NotificationService)
        public registerDriver(Driver driver)
        public completeDelivery(Long orderId, Long driverId)
    }

        class Rating {
        private Long id
        private Long customerId
        private Long driverId
        private int score
        private String comment
        private LocalDateTime timestamp
        public Rating(Long customerId, Long driverId, int score, String comment)
        public boolean validate()
        public String getRatingDetails()
        public Long getId()
        public Long getCustomerId()
        public Long getDriverId()
        public int getScore()
        public String getComment()
        public LocalDateTime getTimestamp()
    }

    class RatingsHandler {
        private int maxRatings
        private Deque~T~ ratingsQueue
        public RatingsHandler(int maxRatings)
        public void addRating(T rating)
        public Optional~T~ removeOldestRating()
        public Optional~T~ getLatestRating()
        public void enforceRatingQueueMaxSize()
        public void clearAllRatings()
        public boolean isRatingQueueEmpty()
        public boolean isRatingQueueFull()
        public int getCurrentRatingCount()
        public double calculateAverageRating()
        public int getMaxRatings()
    }

    class RatingsBusinessLogic {
        <<interface>>
        public void addRating(T rating)
        public Optional~T~ removeOldestRating()
        public Optional~T~ getLatestRating()
        public void clearAllRatings()
        public boolean isRatingQueueEmpty()
        public boolean isRatingQueueFull()
        public int getCurrentRatingCount()
        public void enforceRatingQueueMaxSize()
        public double calculateAverageRating()
        public int getMaxRatings()
    }

    class Payment {
        private Long paymentId
        private Long orderId
        private String paymentMethod
        private double amount
        private LocalDateTime paymentTime
        private boolean isProcessed
        private boolean isRefunded
        public Payment(Long orderId, String paymentMethod, double amount)
        public boolean processPayment()
        public boolean refundPayment()
        public Long getPaymentId()
        public Long getOrderId()
        public String getPaymentMethod()
        public double getAmount()
        public LocalDateTime getPaymentTime()
        public boolean isProcessed()
        public boolean isRefunded()
    }

    class Fries {
        private Size size
        public calculateTotal()
    }

    %% Add Rating relationships
    RatingsBusinessLogic <|.. RatingsHandler
    RatingsHandler --> Rating

    class OrderQueue {
        private Queue~Order~ orders
        private int maxQueueSize
        private OrderValidator validator
        public OrderQueue(int maxQueueSize)
        public void enqueue(Order order)
        public Optional~Order~ dequeue()
        public Optional~Order~ peek()
        public boolean isEmpty()
        public int size()
        public void clear()
        public List~Order~ getPendingOrders()
    }

    class OrderValidator {
        <<interface>>
        public boolean validate(Order order)
    }

    %% Relationships
    MenuItem <|-- Fries
    MenuItem <|-- Hamburger
    MenuItem <|-- Drink
    OrderSubject <|.. OrderTrackingService
    OrderObserver <|.. CustomerNotifier
    MenuItemFactory ..> MenuItem
    Order o-- MenuItem
    Customer "1" --> "*" Order : places
    Order "*" --> "*" MenuItem : contains
    Driver "1" --> "*" Order : accepts
    Customer "1" --> "*" Rating : gives
    Driver "1" --> "*" Rating : receives
    Order --> OrderStatus : has
    Order "1" --> "1" Payment : includes
    DeliverySystem --> OrderQueue
    OrderQueue --> Order
    OrderQueue --> OrderValidator : uses
```

# Online Food Delivery System Design Documentation

## Class Structure and Relationships

The system is designed with clear separation of concerns and follows object-oriented principles:

### Core Classes
1. **Customer**: Manages customer information and order placement
2. **Driver**: Handles delivery operations, location tracking, and rating management
3. **Order**: Processes order details and status tracking
4. **MenuItem**: Base class for food items with size and customization options
5. **OrderTracker**: Manages order status updates and notifications

## OOP Principles Implementation

### 1. Encapsulation

The codebase demonstrates strong encapsulation through:

Example from MenuItem class:
```java
public abstract class MenuItem {
    private Long id;
    private String name;
    private String description;
    private double price;
    private String category;
    private int preparationTime;
    private boolean available;

    // Controlled access through Optional
    public Optional<String> getDescription() {
        return Optional.ofNullable(description);
    }
}
```

### 2. Abstraction

The system uses both interfaces and abstract classes:

1. **Interfaces**:
- `OrderObserver`: Defines notification behavior
- `OrderSubject`: Defines subject behavior for observer pattern
- `DriverMatchingStrategy`: Abstracts driver matching logic

2. **Abstract Classes**:
- `MenuItem`: Base class for all menu items with common properties

### 3. Inheritance

The system uses inheritance through the MenuItem hierarchy, managed by MenuItemFactory:

```java
public MenuItem createMenuItem(String type, String name, String description, double basePrice) {
    return switch (type.toLowerCase()) {
        case "hamburger" -> new Hamburger(nextId++, name, description, basePrice);
        case "drink" -> new Drink(nextId++, name, description, basePrice, Size.MEDIUM);
        case "fries" -> new Fries(nextId++, name, description, basePrice, Size.MEDIUM);
        default -> throw new IllegalArgumentException("Unknown menu item type: " + type);
    };
}
```

### 4. Polymorphism

Demonstrated through:

1. **Interface Implementation**:
```java
public class CustomerNotifier implements OrderObserver {
    private final NotificationService notificationService;

    @Override
    public void update(Order order) {
        notificationService.sendOrderStatusUpdateToCustomer(order, order.getStatus());
    }
}
```

2. **Method Overriding**: Different implementations for different menu items and strategies

## Design Patterns

### 1. Builder Pattern

Used for complex order construction with validation:

```java
public class OrderBuilder {
    private Long customerId;
    private List<MenuItem> items = new ArrayList<>();
    private Location deliveryLocation;
    private String customerEmail;

    public OrderBuilder withValidatedCustomerId(Long customerId) {
        if (customerId == null || customerId <= 0) {
            throw new IllegalArgumentException("Invalid customer ID");
        }
        this.customerId = customerId;
        return this;
    }

    // Additional builder methods...

    public Order build() {
        validateOrderRequirements();
        return new Order(customerId, items, deliveryLocation, customerEmail);
    }
}
```

### 2. Observer Pattern

Implemented for order tracking and notifications:

```java
public class OrderTrackingService implements OrderSubject {
    private List<OrderObserver> observers = new ArrayList<>();

    @Override
    public void attach(OrderObserver observer) {
        observers.add(observer);
    }

    @Override
    public void notifyObservers(Order order) {
        for (OrderObserver observer : observers) {
            observer.update(order);
        }
    }
}
```

### 3. Factory Pattern

Used for creating menu items with consistent ID generation:

```java
public class MenuItemFactory {
    private static long nextId = 1;

    public MenuItem createMenuItem(String type, String name, String description, double basePrice) {
        return switch (type.toLowerCase()) {
            case "hamburger" -> new Hamburger(nextId++, name, description, basePrice);
            case "drink" -> new Drink(nextId++, name, description, basePrice, Size.MEDIUM);
            case "fries" -> new Fries(nextId++, name, description, basePrice, Size.MEDIUM);
            default -> throw new IllegalArgumentException("Unknown menu item type: " + type);
        };
    }
}
```

### 4. Strategy Pattern

Used for flexible driver matching algorithms:

```java
public interface DriverMatchingStrategy {
    Optional<Driver> findBestMatch(Order order, List<Driver> availableDrivers);
}

// Implementation in ProximityBasedMatchingStrategy
public Optional<Driver> findBestMatch(Order order, List<Driver> availableDrivers) {
    // Implementation specific to proximity-based matching
}
```

The system demonstrates modern Java practices through:
- Use of Optional for null safety
- Strong validation in builders
- Immutable objects where appropriate
- Thread-safe collections (ConcurrentHashMap)
- Clear separation of concerns

## Class Diagram
```mermaid 
classDiagram
    %% Menu Package
    class MenuItem {
        <<abstract>>
        -Long id
        -String name
        -String description
        -double price
        -String category
        -int preparationTime
        -boolean available
        +calculateTotal()
        +updatePrice(double)
        +isAvailable()
        +getDetails()
    }
    
    class Hamburger {
        -List~Topping~ toppings
        +addTopping(Topping)
        +calculateTotal()
    }
    
    class Drink {
        -Size size
        +calculateTotal()
    }
    
    class Size {
        <<enumeration>>
        SMALL
        MEDIUM
        LARGE
        -double priceMultiplier
    }
    
    class Topping {
        -String name
        -double price
    }

    %% Order Package
    class Order {
        -Long orderId
        -Long customerId
        -Long driverId
        -List~MenuItem~ items
        -OrderStatus status
        -double totalAmount
        -LocalDateTime orderTime
        -Payment payment
        -Location deliveryLocation
        +calculateTotal()
        +updateStatus()
    }

    class OrderStatus {
        <<enumeration>>
        PLACED
        ACCEPTED
        IN_DELIVERY
        DELIVERED
    }

    %% Observer Package
    class OrderSubject {
        <<interface>>
        +attach(OrderObserver)
        +detach(OrderObserver)
        +notifyObservers(Order)
    }

    class OrderObserver {
        <<interface>>
        +update(Order)
    }

    class OrderTrackingService {
        -List~OrderObserver~ observers
        +attach(OrderObserver)
        +detach(OrderObserver)
        +notifyObservers(Order)
    }

    class CustomerNotifier {
        -NotificationService notificationService
        +update(Order)
    }

    %% User Package
    class Customer {
        -Long id
        -String name
        -String address
        -String phone
        -String email
        -List~Order~ orderHistory
        +placeOrder(List~MenuItem~)
        +rateDriver(Driver, int, String)
    }

    class Driver {
        -Long id
        -String name
        -String vehicle
        -String licenseNumber
        -Location currentLocation
        -RatingsHandler ratings
        -Order currentOrder
        -boolean isAvailable
        +acceptOrder(Order)
        +completeDelivery(Order)
    }

    %% Factory Package
    class MenuItemFactory {
        -static long nextId
        +createMenuItem(String, String, String, double)
        +createCustomMenuItem(String, String, String, double, Size)
    }

    %% Main Package
    class DeliverySystem {
        -OrderQueue orderQueue
        -Map~Long, Driver~ availableDrivers
        -Map~Long, Driver~ busyDrivers
        -OrderTracker orderTracker
        -DriverMatchingStrategy driverMatcher
        -NotificationService notificationService
        +registerDriver(Driver)
        +completeDelivery(Long, Long)
    }

    %% Relationships
    MenuItem <|-- Hamburger
    MenuItem <|-- Drink
    OrderSubject <|.. OrderTrackingService
    OrderObserver <|.. CustomerNotifier
    MenuItemFactory ..> MenuItem
    Order o-- MenuItem
    Customer --> Order
    Driver --> Order
    DeliverySystem --> OrderQueue
    DeliverySystem --> Driver
    Hamburger --> Topping
    Drink --> Size
    Order --> OrderStatus
    CustomerNotifier --> NotificationService
```
